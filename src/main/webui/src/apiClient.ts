/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * pricekeep API
 * OpenAPI spec version: 1.0.0-SNAPSHOT
 */
import { useMutation, useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";

import { computed, unref } from "vue";
import type { MaybeRef } from "vue";

import type {
  ExternalProductQueryMessage,
  GetApiAdminStoreSearchParams,
  GetApiCommonLatestDealsParams,
  GetApiProductAllParams,
  GetApiProductProductIdQuoteHistParams,
  GetApiProductSearchParams,
  GetApiProductSuggestParams,
  JobInfo,
  ProductInfo,
  ProductQuoteImportBatchDTO,
  ProductResult,
  QuoteDTO,
  QuoteResult,
  StoreImportBatchDTO,
  StoreInfo,
} from "./model";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * @summary Create Alert
 */
export type postApiAdminAlertNewResponse201 = {
  data: void;
  status: 201;
};

export type postApiAdminAlertNewResponseSuccess =
  postApiAdminAlertNewResponse201 & {
    headers: Headers;
  };
export type postApiAdminAlertNewResponse = postApiAdminAlertNewResponseSuccess;

export const getPostApiAdminAlertNewUrl = () => {
  return `/api/admin/alert/new`;
};

export const postApiAdminAlertNew = async (
  options?: RequestInit,
): Promise<postApiAdminAlertNewResponse> => {
  const res = await fetch(getPostApiAdminAlertNewUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiAdminAlertNewResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiAdminAlertNewResponse;
};

export const getPostApiAdminAlertNewMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiAdminAlertNew>>,
    TError,
    void,
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiAdminAlertNew>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["postApiAdminAlertNew"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiAdminAlertNew>>,
    void
  > = () => {
    return postApiAdminAlertNew(fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiAdminAlertNewMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiAdminAlertNew>>
>;

export type PostApiAdminAlertNewMutationError = unknown;

/**
 * @summary Create Alert
 */
export const usePostApiAdminAlertNew = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiAdminAlertNew>>,
      TError,
      void,
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiAdminAlertNew>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPostApiAdminAlertNewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get All Jobs
 */
export type getApiAdminBatchAllResponse200 = {
  data: JobInfo[];
  status: 200;
};

export type getApiAdminBatchAllResponseSuccess =
  getApiAdminBatchAllResponse200 & {
    headers: Headers;
  };
export type getApiAdminBatchAllResponse = getApiAdminBatchAllResponseSuccess;

export const getGetApiAdminBatchAllUrl = () => {
  return `/api/admin/batch/all`;
};

export const getApiAdminBatchAll = async (
  options?: RequestInit,
): Promise<getApiAdminBatchAllResponse> => {
  const res = await fetch(getGetApiAdminBatchAllUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiAdminBatchAllResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiAdminBatchAllResponse;
};

export const getGetApiAdminBatchAllQueryKey = () => {
  return ["api", "admin", "batch", "all"] as const;
};

export const getGetApiAdminBatchAllQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiAdminBatchAll>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getApiAdminBatchAll>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiAdminBatchAllQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiAdminBatchAll>>
  > = ({ signal }) => getApiAdminBatchAll({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiAdminBatchAll>>,
    TError,
    TData
  >;
};

export type GetApiAdminBatchAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiAdminBatchAll>>
>;
export type GetApiAdminBatchAllQueryError = unknown;

/**
 * @summary Get All Jobs
 */

export function useGetApiAdminBatchAll<
  TData = Awaited<ReturnType<typeof getApiAdminBatchAll>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiAdminBatchAll>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiAdminBatchAllQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Create Batch
 */
export type postApiAdminBatchNewProductQuoteImportResponse201 = {
  data: void;
  status: 201;
};

export type postApiAdminBatchNewProductQuoteImportResponse400 = {
  data: void;
  status: 400;
};

export type postApiAdminBatchNewProductQuoteImportResponseSuccess =
  postApiAdminBatchNewProductQuoteImportResponse201 & {
    headers: Headers;
  };
export type postApiAdminBatchNewProductQuoteImportResponseError =
  postApiAdminBatchNewProductQuoteImportResponse400 & {
    headers: Headers;
  };

export type postApiAdminBatchNewProductQuoteImportResponse =
  | postApiAdminBatchNewProductQuoteImportResponseSuccess
  | postApiAdminBatchNewProductQuoteImportResponseError;

export const getPostApiAdminBatchNewProductQuoteImportUrl = () => {
  return `/api/admin/batch/newProductQuoteImport`;
};

export const postApiAdminBatchNewProductQuoteImport = async (
  productQuoteImportBatchDTO: ProductQuoteImportBatchDTO,
  options?: RequestInit,
): Promise<postApiAdminBatchNewProductQuoteImportResponse> => {
  const res = await fetch(getPostApiAdminBatchNewProductQuoteImportUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(productQuoteImportBatchDTO),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiAdminBatchNewProductQuoteImportResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiAdminBatchNewProductQuoteImportResponse;
};

export const getPostApiAdminBatchNewProductQuoteImportMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiAdminBatchNewProductQuoteImport>>,
    TError,
    { data: ProductQuoteImportBatchDTO },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiAdminBatchNewProductQuoteImport>>,
  TError,
  { data: ProductQuoteImportBatchDTO },
  TContext
> => {
  const mutationKey = ["postApiAdminBatchNewProductQuoteImport"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiAdminBatchNewProductQuoteImport>>,
    { data: ProductQuoteImportBatchDTO }
  > = (props) => {
    const { data } = props ?? {};

    return postApiAdminBatchNewProductQuoteImport(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiAdminBatchNewProductQuoteImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiAdminBatchNewProductQuoteImport>>
>;
export type PostApiAdminBatchNewProductQuoteImportMutationBody =
  ProductQuoteImportBatchDTO;
export type PostApiAdminBatchNewProductQuoteImportMutationError = void;

/**
 * @summary Create Batch
 */
export const usePostApiAdminBatchNewProductQuoteImport = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiAdminBatchNewProductQuoteImport>>,
      TError,
      { data: ProductQuoteImportBatchDTO },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiAdminBatchNewProductQuoteImport>>,
  TError,
  { data: ProductQuoteImportBatchDTO },
  TContext
> => {
  const mutationOptions =
    getPostApiAdminBatchNewProductQuoteImportMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Batch
 */
export type postApiAdminBatchNewStoreImportResponse201 = {
  data: void;
  status: 201;
};

export type postApiAdminBatchNewStoreImportResponse400 = {
  data: void;
  status: 400;
};

export type postApiAdminBatchNewStoreImportResponseSuccess =
  postApiAdminBatchNewStoreImportResponse201 & {
    headers: Headers;
  };
export type postApiAdminBatchNewStoreImportResponseError =
  postApiAdminBatchNewStoreImportResponse400 & {
    headers: Headers;
  };

export type postApiAdminBatchNewStoreImportResponse =
  | postApiAdminBatchNewStoreImportResponseSuccess
  | postApiAdminBatchNewStoreImportResponseError;

export const getPostApiAdminBatchNewStoreImportUrl = () => {
  return `/api/admin/batch/newStoreImport`;
};

export const postApiAdminBatchNewStoreImport = async (
  storeImportBatchDTO: StoreImportBatchDTO,
  options?: RequestInit,
): Promise<postApiAdminBatchNewStoreImportResponse> => {
  const res = await fetch(getPostApiAdminBatchNewStoreImportUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(storeImportBatchDTO),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiAdminBatchNewStoreImportResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiAdminBatchNewStoreImportResponse;
};

export const getPostApiAdminBatchNewStoreImportMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiAdminBatchNewStoreImport>>,
    TError,
    { data: StoreImportBatchDTO },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiAdminBatchNewStoreImport>>,
  TError,
  { data: StoreImportBatchDTO },
  TContext
> => {
  const mutationKey = ["postApiAdminBatchNewStoreImport"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiAdminBatchNewStoreImport>>,
    { data: StoreImportBatchDTO }
  > = (props) => {
    const { data } = props ?? {};

    return postApiAdminBatchNewStoreImport(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiAdminBatchNewStoreImportMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiAdminBatchNewStoreImport>>
>;
export type PostApiAdminBatchNewStoreImportMutationBody = StoreImportBatchDTO;
export type PostApiAdminBatchNewStoreImportMutationError = void;

/**
 * @summary Create Batch
 */
export const usePostApiAdminBatchNewStoreImport = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiAdminBatchNewStoreImport>>,
      TError,
      { data: StoreImportBatchDTO },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiAdminBatchNewStoreImport>>,
  TError,
  { data: StoreImportBatchDTO },
  TContext
> => {
  const mutationOptions =
    getPostApiAdminBatchNewStoreImportMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Run Batch
 */
export type postApiAdminBatchRunBatchIdResponse200 = {
  data: unknown;
  status: 200;
};

export type postApiAdminBatchRunBatchIdResponseSuccess =
  postApiAdminBatchRunBatchIdResponse200 & {
    headers: Headers;
  };
export type postApiAdminBatchRunBatchIdResponse =
  postApiAdminBatchRunBatchIdResponseSuccess;

export const getPostApiAdminBatchRunBatchIdUrl = (batchId: number) => {
  return `/api/admin/batch/run/${batchId}`;
};

export const postApiAdminBatchRunBatchId = async (
  batchId: number,
  options?: RequestInit,
): Promise<postApiAdminBatchRunBatchIdResponse> => {
  const res = await fetch(getPostApiAdminBatchRunBatchIdUrl(batchId), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiAdminBatchRunBatchIdResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiAdminBatchRunBatchIdResponse;
};

export const getPostApiAdminBatchRunBatchIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiAdminBatchRunBatchId>>,
    TError,
    { batchId: number },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiAdminBatchRunBatchId>>,
  TError,
  { batchId: number },
  TContext
> => {
  const mutationKey = ["postApiAdminBatchRunBatchId"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiAdminBatchRunBatchId>>,
    { batchId: number }
  > = (props) => {
    const { batchId } = props ?? {};

    return postApiAdminBatchRunBatchId(batchId, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiAdminBatchRunBatchIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiAdminBatchRunBatchId>>
>;

export type PostApiAdminBatchRunBatchIdMutationError = unknown;

/**
 * @summary Run Batch
 */
export const usePostApiAdminBatchRunBatchId = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiAdminBatchRunBatchId>>,
      TError,
      { batchId: number },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiAdminBatchRunBatchId>>,
  TError,
  { batchId: number },
  TContext
> => {
  const mutationOptions =
    getPostApiAdminBatchRunBatchIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create Store
 */
export type postApiAdminStoreNewResponse201 = {
  data: void;
  status: 201;
};

export type postApiAdminStoreNewResponseSuccess =
  postApiAdminStoreNewResponse201 & {
    headers: Headers;
  };
export type postApiAdminStoreNewResponse = postApiAdminStoreNewResponseSuccess;

export const getPostApiAdminStoreNewUrl = () => {
  return `/api/admin/store/new`;
};

export const postApiAdminStoreNew = async (
  options?: RequestInit,
): Promise<postApiAdminStoreNewResponse> => {
  const res = await fetch(getPostApiAdminStoreNewUrl(), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiAdminStoreNewResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiAdminStoreNewResponse;
};

export const getPostApiAdminStoreNewMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiAdminStoreNew>>,
    TError,
    void,
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiAdminStoreNew>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["postApiAdminStoreNew"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiAdminStoreNew>>,
    void
  > = () => {
    return postApiAdminStoreNew(fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiAdminStoreNewMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiAdminStoreNew>>
>;

export type PostApiAdminStoreNewMutationError = unknown;

/**
 * @summary Create Store
 */
export const usePostApiAdminStoreNew = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiAdminStoreNew>>,
      TError,
      void,
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiAdminStoreNew>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPostApiAdminStoreNewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get All Stores
 */
export type getApiAdminStoreSearchResponse200 = {
  data: StoreInfo[];
  status: 200;
};

export type getApiAdminStoreSearchResponseSuccess =
  getApiAdminStoreSearchResponse200 & {
    headers: Headers;
  };
export type getApiAdminStoreSearchResponse =
  getApiAdminStoreSearchResponseSuccess;

export const getGetApiAdminStoreSearchUrl = (
  params?: GetApiAdminStoreSearchParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/admin/store/search?${stringifiedParams}`
    : `/api/admin/store/search`;
};

export const getApiAdminStoreSearch = async (
  params?: GetApiAdminStoreSearchParams,
  options?: RequestInit,
): Promise<getApiAdminStoreSearchResponse> => {
  const res = await fetch(getGetApiAdminStoreSearchUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiAdminStoreSearchResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiAdminStoreSearchResponse;
};

export const getGetApiAdminStoreSearchQueryKey = (
  params?: MaybeRef<GetApiAdminStoreSearchParams>,
) => {
  return [
    "api",
    "admin",
    "store",
    "search",
    ...(params ? [params] : []),
  ] as const;
};

export const getGetApiAdminStoreSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiAdminStoreSearch>>,
  TError = unknown,
>(
  params?: MaybeRef<GetApiAdminStoreSearchParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiAdminStoreSearch>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiAdminStoreSearchQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiAdminStoreSearch>>
  > = ({ signal }) =>
    getApiAdminStoreSearch(unref(params), { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiAdminStoreSearch>>,
    TError,
    TData
  >;
};

export type GetApiAdminStoreSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiAdminStoreSearch>>
>;
export type GetApiAdminStoreSearchQueryError = unknown;

/**
 * @summary Get All Stores
 */

export function useGetApiAdminStoreSearch<
  TData = Awaited<ReturnType<typeof getApiAdminStoreSearch>>,
  TError = unknown,
>(
  params?: MaybeRef<GetApiAdminStoreSearchParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiAdminStoreSearch>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiAdminStoreSearchQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get Recent Discount
 */
export type getApiCommonLatestDealsResponse200 = {
  data: QuoteResult;
  status: 200;
};

export type getApiCommonLatestDealsResponseSuccess =
  getApiCommonLatestDealsResponse200 & {
    headers: Headers;
  };
export type getApiCommonLatestDealsResponse =
  getApiCommonLatestDealsResponseSuccess;

export const getGetApiCommonLatestDealsUrl = (
  params?: GetApiCommonLatestDealsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/common/latestDeals?${stringifiedParams}`
    : `/api/common/latestDeals`;
};

export const getApiCommonLatestDeals = async (
  params?: GetApiCommonLatestDealsParams,
  options?: RequestInit,
): Promise<getApiCommonLatestDealsResponse> => {
  const res = await fetch(getGetApiCommonLatestDealsUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiCommonLatestDealsResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiCommonLatestDealsResponse;
};

export const getGetApiCommonLatestDealsQueryKey = (
  params?: MaybeRef<GetApiCommonLatestDealsParams>,
) => {
  return ["api", "common", "latestDeals", ...(params ? [params] : [])] as const;
};

export const getGetApiCommonLatestDealsQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiCommonLatestDeals>>,
  TError = unknown,
>(
  params?: MaybeRef<GetApiCommonLatestDealsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiCommonLatestDeals>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiCommonLatestDealsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiCommonLatestDeals>>
  > = ({ signal }) =>
    getApiCommonLatestDeals(unref(params), { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiCommonLatestDeals>>,
    TError,
    TData
  >;
};

export type GetApiCommonLatestDealsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiCommonLatestDeals>>
>;
export type GetApiCommonLatestDealsQueryError = unknown;

/**
 * @summary Get Recent Discount
 */

export function useGetApiCommonLatestDeals<
  TData = Awaited<ReturnType<typeof getApiCommonLatestDeals>>,
  TError = unknown,
>(
  params?: MaybeRef<GetApiCommonLatestDealsParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiCommonLatestDeals>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiCommonLatestDealsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get Today Alert Trigger
 */
export type getApiProductAlertsResponse200 = {
  data: QuoteDTO[];
  status: 200;
};

export type getApiProductAlertsResponseSuccess =
  getApiProductAlertsResponse200 & {
    headers: Headers;
  };
export type getApiProductAlertsResponse = getApiProductAlertsResponseSuccess;

export const getGetApiProductAlertsUrl = () => {
  return `/api/product/alerts`;
};

export const getApiProductAlerts = async (
  options?: RequestInit,
): Promise<getApiProductAlertsResponse> => {
  const res = await fetch(getGetApiProductAlertsUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductAlertsResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductAlertsResponse;
};

export const getGetApiProductAlertsQueryKey = () => {
  return ["api", "product", "alerts"] as const;
};

export const getGetApiProductAlertsQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductAlerts>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getApiProductAlerts>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductAlertsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductAlerts>>
  > = ({ signal }) => getApiProductAlerts({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductAlerts>>,
    TError,
    TData
  >;
};

export type GetApiProductAlertsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductAlerts>>
>;
export type GetApiProductAlertsQueryError = unknown;

/**
 * @summary Get Today Alert Trigger
 */

export function useGetApiProductAlerts<
  TData = Awaited<ReturnType<typeof getApiProductAlerts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductAlerts>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductAlertsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get All Product
 */
export type getApiProductAllResponse200 = {
  data: ProductResult;
  status: 200;
};

export type getApiProductAllResponseSuccess = getApiProductAllResponse200 & {
  headers: Headers;
};
export type getApiProductAllResponse = getApiProductAllResponseSuccess;

export const getGetApiProductAllUrl = (params?: GetApiProductAllParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product/all?${stringifiedParams}`
    : `/api/product/all`;
};

export const getApiProductAll = async (
  params?: GetApiProductAllParams,
  options?: RequestInit,
): Promise<getApiProductAllResponse> => {
  const res = await fetch(getGetApiProductAllUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductAllResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductAllResponse;
};

export const getGetApiProductAllQueryKey = (
  params?: MaybeRef<GetApiProductAllParams>,
) => {
  return ["api", "product", "all", ...(params ? [params] : [])] as const;
};

export const getGetApiProductAllQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductAll>>,
  TError = unknown,
>(
  params?: MaybeRef<GetApiProductAllParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductAll>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductAllQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductAll>>
  > = ({ signal }) =>
    getApiProductAll(unref(params), { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductAll>>,
    TError,
    TData
  >;
};

export type GetApiProductAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductAll>>
>;
export type GetApiProductAllQueryError = unknown;

/**
 * @summary Get All Product
 */

export function useGetApiProductAll<
  TData = Awaited<ReturnType<typeof getApiProductAll>>,
  TError = unknown,
>(
  params?: MaybeRef<GetApiProductAllParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductAll>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get Available Ext Sources
 */
export type getApiProductExtSourcesResponse200 = {
  data: string[];
  status: 200;
};

export type getApiProductExtSourcesResponseSuccess =
  getApiProductExtSourcesResponse200 & {
    headers: Headers;
  };
export type getApiProductExtSourcesResponse =
  getApiProductExtSourcesResponseSuccess;

export const getGetApiProductExtSourcesUrl = () => {
  return `/api/product/extSources`;
};

export const getApiProductExtSources = async (
  options?: RequestInit,
): Promise<getApiProductExtSourcesResponse> => {
  const res = await fetch(getGetApiProductExtSourcesUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductExtSourcesResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductExtSourcesResponse;
};

export const getGetApiProductExtSourcesQueryKey = () => {
  return ["api", "product", "extSources"] as const;
};

export const getGetApiProductExtSourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductExtSources>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getApiProductExtSources>>,
      TError,
      TData
    >
  >;
  fetch?: RequestInit;
}) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductExtSourcesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductExtSources>>
  > = ({ signal }) => getApiProductExtSources({ signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductExtSources>>,
    TError,
    TData
  >;
};

export type GetApiProductExtSourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductExtSources>>
>;
export type GetApiProductExtSourcesQueryError = unknown;

/**
 * @summary Get Available Ext Sources
 */

export function useGetApiProductExtSources<
  TData = Awaited<ReturnType<typeof getApiProductExtSources>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductExtSources>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductExtSourcesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get Product By Gtin
 */
export type getApiProductGtinGtinResponse200 = {
  data: ProductInfo;
  status: 200;
};

export type getApiProductGtinGtinResponseSuccess =
  getApiProductGtinGtinResponse200 & {
    headers: Headers;
  };
export type getApiProductGtinGtinResponse =
  getApiProductGtinGtinResponseSuccess;

export const getGetApiProductGtinGtinUrl = (gtin: string) => {
  return `/api/product/gtin/${gtin}`;
};

export const getApiProductGtinGtin = async (
  gtin: string,
  options?: RequestInit,
): Promise<getApiProductGtinGtinResponse> => {
  const res = await fetch(getGetApiProductGtinGtinUrl(gtin), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductGtinGtinResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductGtinGtinResponse;
};

export const getGetApiProductGtinGtinQueryKey = (gtin?: MaybeRef<string>) => {
  return ["api", "product", "gtin", gtin] as const;
};

export const getGetApiProductGtinGtinQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductGtinGtin>>,
  TError = unknown,
>(
  gtin: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductGtinGtin>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductGtinGtinQueryKey(gtin);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductGtinGtin>>
  > = ({ signal }) =>
    getApiProductGtinGtin(unref(gtin), { signal, ...fetchOptions });

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(gtin)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductGtinGtin>>,
    TError,
    TData
  >;
};

export type GetApiProductGtinGtinQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductGtinGtin>>
>;
export type GetApiProductGtinGtinQueryError = unknown;

/**
 * @summary Get Product By Gtin
 */

export function useGetApiProductGtinGtin<
  TData = Awaited<ReturnType<typeof getApiProductGtinGtin>>,
  TError = unknown,
>(
  gtin: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductGtinGtin>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductGtinGtinQueryOptions(gtin, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Create Product
 */
export type postApiProductNewResponse201 = {
  data: ProductInfo;
  status: 201;
};

export type postApiProductNewResponseSuccess = postApiProductNewResponse201 & {
  headers: Headers;
};
export type postApiProductNewResponse = postApiProductNewResponseSuccess;

export const getPostApiProductNewUrl = () => {
  return `/api/product/new`;
};

export const postApiProductNew = async (
  productInfo: NonReadonly<ProductInfo>,
  options?: RequestInit,
): Promise<postApiProductNewResponse> => {
  const res = await fetch(getPostApiProductNewUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(productInfo),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiProductNewResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiProductNewResponse;
};

export const getPostApiProductNewMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiProductNew>>,
    TError,
    { data: NonReadonly<ProductInfo> },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiProductNew>>,
  TError,
  { data: NonReadonly<ProductInfo> },
  TContext
> => {
  const mutationKey = ["postApiProductNew"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiProductNew>>,
    { data: NonReadonly<ProductInfo> }
  > = (props) => {
    const { data } = props ?? {};

    return postApiProductNew(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiProductNewMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiProductNew>>
>;
export type PostApiProductNewMutationBody = NonReadonly<ProductInfo>;
export type PostApiProductNewMutationError = unknown;

/**
 * @summary Create Product
 */
export const usePostApiProductNew = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiProductNew>>,
      TError,
      { data: NonReadonly<ProductInfo> },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiProductNew>>,
  TError,
  { data: NonReadonly<ProductInfo> },
  TContext
> => {
  const mutationOptions = getPostApiProductNewMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Search Product
 */
export type getApiProductSearchResponse200 = {
  data: ProductInfo[];
  status: 200;
};

export type getApiProductSearchResponseSuccess =
  getApiProductSearchResponse200 & {
    headers: Headers;
  };
export type getApiProductSearchResponse = getApiProductSearchResponseSuccess;

export const getGetApiProductSearchUrl = (
  params: GetApiProductSearchParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product/search?${stringifiedParams}`
    : `/api/product/search`;
};

export const getApiProductSearch = async (
  params: GetApiProductSearchParams,
  options?: RequestInit,
): Promise<getApiProductSearchResponse> => {
  const res = await fetch(getGetApiProductSearchUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductSearchResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductSearchResponse;
};

export const getGetApiProductSearchQueryKey = (
  params?: MaybeRef<GetApiProductSearchParams>,
) => {
  return ["api", "product", "search", ...(params ? [params] : [])] as const;
};

export const getGetApiProductSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductSearch>>,
  TError = unknown,
>(
  params: MaybeRef<GetApiProductSearchParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductSearch>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductSearchQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductSearch>>
  > = ({ signal }) =>
    getApiProductSearch(unref(params), { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductSearch>>,
    TError,
    TData
  >;
};

export type GetApiProductSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductSearch>>
>;
export type GetApiProductSearchQueryError = unknown;

/**
 * @summary Search Product
 */

export function useGetApiProductSearch<
  TData = Awaited<ReturnType<typeof getApiProductSearch>>,
  TError = unknown,
>(
  params: MaybeRef<GetApiProductSearchParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductSearch>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductSearchQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Find External Product
 */
export type postApiProductSearchExtResponse200 = {
  data: QuoteDTO[];
  status: 200;
};

export type postApiProductSearchExtResponse400 = {
  data: void;
  status: 400;
};

export type postApiProductSearchExtResponseSuccess =
  postApiProductSearchExtResponse200 & {
    headers: Headers;
  };
export type postApiProductSearchExtResponseError =
  postApiProductSearchExtResponse400 & {
    headers: Headers;
  };

export type postApiProductSearchExtResponse =
  | postApiProductSearchExtResponseSuccess
  | postApiProductSearchExtResponseError;

export const getPostApiProductSearchExtUrl = () => {
  return `/api/product/searchExt`;
};

export const postApiProductSearchExt = async (
  externalProductQueryMessage: ExternalProductQueryMessage,
  options?: RequestInit,
): Promise<postApiProductSearchExtResponse> => {
  const res = await fetch(getPostApiProductSearchExtUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(externalProductQueryMessage),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiProductSearchExtResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiProductSearchExtResponse;
};

export const getPostApiProductSearchExtMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiProductSearchExt>>,
    TError,
    { data: ExternalProductQueryMessage },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiProductSearchExt>>,
  TError,
  { data: ExternalProductQueryMessage },
  TContext
> => {
  const mutationKey = ["postApiProductSearchExt"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiProductSearchExt>>,
    { data: ExternalProductQueryMessage }
  > = (props) => {
    const { data } = props ?? {};

    return postApiProductSearchExt(data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiProductSearchExtMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiProductSearchExt>>
>;
export type PostApiProductSearchExtMutationBody = ExternalProductQueryMessage;
export type PostApiProductSearchExtMutationError = void;

/**
 * @summary Find External Product
 */
export const usePostApiProductSearchExt = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiProductSearchExt>>,
      TError,
      { data: ExternalProductQueryMessage },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiProductSearchExt>>,
  TError,
  { data: ExternalProductQueryMessage },
  TContext
> => {
  const mutationOptions = getPostApiProductSearchExtMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Suggested Words
 */
export type getApiProductSuggestResponse200 = {
  data: string[];
  status: 200;
};

export type getApiProductSuggestResponseSuccess =
  getApiProductSuggestResponse200 & {
    headers: Headers;
  };
export type getApiProductSuggestResponse = getApiProductSuggestResponseSuccess;

export const getGetApiProductSuggestUrl = (
  params: GetApiProductSuggestParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product/suggest?${stringifiedParams}`
    : `/api/product/suggest`;
};

export const getApiProductSuggest = async (
  params: GetApiProductSuggestParams,
  options?: RequestInit,
): Promise<getApiProductSuggestResponse> => {
  const res = await fetch(getGetApiProductSuggestUrl(params), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductSuggestResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductSuggestResponse;
};

export const getGetApiProductSuggestQueryKey = (
  params?: MaybeRef<GetApiProductSuggestParams>,
) => {
  return ["api", "product", "suggest", ...(params ? [params] : [])] as const;
};

export const getGetApiProductSuggestQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductSuggest>>,
  TError = unknown,
>(
  params: MaybeRef<GetApiProductSuggestParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductSuggest>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductSuggestQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductSuggest>>
  > = ({ signal }) =>
    getApiProductSuggest(unref(params), { signal, ...fetchOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductSuggest>>,
    TError,
    TData
  >;
};

export type GetApiProductSuggestQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductSuggest>>
>;
export type GetApiProductSuggestQueryError = unknown;

/**
 * @summary Suggested Words
 */

export function useGetApiProductSuggest<
  TData = Awaited<ReturnType<typeof getApiProductSuggest>>,
  TError = unknown,
>(
  params: MaybeRef<GetApiProductSuggestParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductSuggest>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductSuggestQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get Product By Id
 */
export type getApiProductProductIdResponse200 = {
  data: ProductInfo;
  status: 200;
};

export type getApiProductProductIdResponseSuccess =
  getApiProductProductIdResponse200 & {
    headers: Headers;
  };
export type getApiProductProductIdResponse =
  getApiProductProductIdResponseSuccess;

export const getGetApiProductProductIdUrl = (productId: number) => {
  return `/api/product/${productId}`;
};

export const getApiProductProductId = async (
  productId: number,
  options?: RequestInit,
): Promise<getApiProductProductIdResponse> => {
  const res = await fetch(getGetApiProductProductIdUrl(productId), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductProductIdResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductProductIdResponse;
};

export const getGetApiProductProductIdQueryKey = (
  productId?: MaybeRef<number>,
) => {
  return ["api", "product", productId] as const;
};

export const getGetApiProductProductIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductProductId>>,
  TError = unknown,
>(
  productId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductProductId>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductProductIdQueryKey(productId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductProductId>>
  > = ({ signal }) =>
    getApiProductProductId(unref(productId), { signal, ...fetchOptions });

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(productId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductProductId>>,
    TError,
    TData
  >;
};

export type GetApiProductProductIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductProductId>>
>;
export type GetApiProductProductIdQueryError = unknown;

/**
 * @summary Get Product By Id
 */

export function useGetApiProductProductId<
  TData = Awaited<ReturnType<typeof getApiProductProductId>>,
  TError = unknown,
>(
  productId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductProductId>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductProductIdQueryOptions(
    productId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Edit Product
 */
export type postApiProductProductIdEditResponse200 = {
  data: unknown;
  status: 200;
};

export type postApiProductProductIdEditResponse400 = {
  data: void;
  status: 400;
};

export type postApiProductProductIdEditResponseSuccess =
  postApiProductProductIdEditResponse200 & {
    headers: Headers;
  };
export type postApiProductProductIdEditResponseError =
  postApiProductProductIdEditResponse400 & {
    headers: Headers;
  };

export type postApiProductProductIdEditResponse =
  | postApiProductProductIdEditResponseSuccess
  | postApiProductProductIdEditResponseError;

export const getPostApiProductProductIdEditUrl = (productId: number) => {
  return `/api/product/${productId}/edit`;
};

export const postApiProductProductIdEdit = async (
  productId: number,
  productInfo: NonReadonly<ProductInfo>,
  options?: RequestInit,
): Promise<postApiProductProductIdEditResponse> => {
  const res = await fetch(getPostApiProductProductIdEditUrl(productId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(productInfo),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiProductProductIdEditResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiProductProductIdEditResponse;
};

export const getPostApiProductProductIdEditMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiProductProductIdEdit>>,
    TError,
    { productId: number; data: NonReadonly<ProductInfo> },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiProductProductIdEdit>>,
  TError,
  { productId: number; data: NonReadonly<ProductInfo> },
  TContext
> => {
  const mutationKey = ["postApiProductProductIdEdit"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiProductProductIdEdit>>,
    { productId: number; data: NonReadonly<ProductInfo> }
  > = (props) => {
    const { productId, data } = props ?? {};

    return postApiProductProductIdEdit(productId, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiProductProductIdEditMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiProductProductIdEdit>>
>;
export type PostApiProductProductIdEditMutationBody = NonReadonly<ProductInfo>;
export type PostApiProductProductIdEditMutationError = void;

/**
 * @summary Edit Product
 */
export const usePostApiProductProductIdEdit = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiProductProductIdEdit>>,
      TError,
      { productId: number; data: NonReadonly<ProductInfo> },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiProductProductIdEdit>>,
  TError,
  { productId: number; data: NonReadonly<ProductInfo> },
  TContext
> => {
  const mutationOptions =
    getPostApiProductProductIdEditMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Quote Price
 */
export type postApiProductProductIdQuoteResponse202 = {
  data: QuoteDTO;
  status: 202;
};

export type postApiProductProductIdQuoteResponseSuccess =
  postApiProductProductIdQuoteResponse202 & {
    headers: Headers;
  };
export type postApiProductProductIdQuoteResponse =
  postApiProductProductIdQuoteResponseSuccess;

export const getPostApiProductProductIdQuoteUrl = (productId: number) => {
  return `/api/product/${productId}/quote`;
};

export const postApiProductProductIdQuote = async (
  productId: number,
  quoteDTO: QuoteDTO,
  options?: RequestInit,
): Promise<postApiProductProductIdQuoteResponse> => {
  const res = await fetch(getPostApiProductProductIdQuoteUrl(productId), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(quoteDTO),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postApiProductProductIdQuoteResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postApiProductProductIdQuoteResponse;
};

export const getPostApiProductProductIdQuoteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postApiProductProductIdQuote>>,
    TError,
    { productId: number; data: QuoteDTO },
    TContext
  >;
  fetch?: RequestInit;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postApiProductProductIdQuote>>,
  TError,
  { productId: number; data: QuoteDTO },
  TContext
> => {
  const mutationKey = ["postApiProductProductIdQuote"];
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postApiProductProductIdQuote>>,
    { productId: number; data: QuoteDTO }
  > = (props) => {
    const { productId, data } = props ?? {};

    return postApiProductProductIdQuote(productId, data, fetchOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostApiProductProductIdQuoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof postApiProductProductIdQuote>>
>;
export type PostApiProductProductIdQuoteMutationBody = QuoteDTO;
export type PostApiProductProductIdQuoteMutationError = unknown;

/**
 * @summary Quote Price
 */
export const usePostApiProductProductIdQuote = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postApiProductProductIdQuote>>,
      TError,
      { productId: number; data: QuoteDTO },
      TContext
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof postApiProductProductIdQuote>>,
  TError,
  { productId: number; data: QuoteDTO },
  TContext
> => {
  const mutationOptions =
    getPostApiProductProductIdQuoteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Price History
 */
export type getApiProductProductIdQuoteHistResponse200 = {
  data: QuoteDTO[];
  status: 200;
};

export type getApiProductProductIdQuoteHistResponseSuccess =
  getApiProductProductIdQuoteHistResponse200 & {
    headers: Headers;
  };
export type getApiProductProductIdQuoteHistResponse =
  getApiProductProductIdQuoteHistResponseSuccess;

export const getGetApiProductProductIdQuoteHistUrl = (
  productId: number,
  params?: GetApiProductProductIdQuoteHistParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/product/${productId}/quoteHist?${stringifiedParams}`
    : `/api/product/${productId}/quoteHist`;
};

export const getApiProductProductIdQuoteHist = async (
  productId: number,
  params?: GetApiProductProductIdQuoteHistParams,
  options?: RequestInit,
): Promise<getApiProductProductIdQuoteHistResponse> => {
  const res = await fetch(
    getGetApiProductProductIdQuoteHistUrl(productId, params),
    {
      ...options,
      method: "GET",
    },
  );

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getApiProductProductIdQuoteHistResponse["data"] = body
    ? JSON.parse(body)
    : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getApiProductProductIdQuoteHistResponse;
};

export const getGetApiProductProductIdQuoteHistQueryKey = (
  productId?: MaybeRef<number>,
  params?: MaybeRef<GetApiProductProductIdQuoteHistParams>,
) => {
  return [
    "api",
    "product",
    productId,
    "quoteHist",
    ...(params ? [params] : []),
  ] as const;
};

export const getGetApiProductProductIdQuoteHistQueryOptions = <
  TData = Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>,
  TError = unknown,
>(
  productId: MaybeRef<number>,
  params?: MaybeRef<GetApiProductProductIdQuoteHistParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
) => {
  const { query: queryOptions, fetch: fetchOptions } = options ?? {};

  const queryKey = getGetApiProductProductIdQuoteHistQueryKey(
    productId,
    params,
  );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>
  > = ({ signal }) =>
    getApiProductProductIdQuoteHist(unref(productId), unref(params), {
      signal,
      ...fetchOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(productId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>,
    TError,
    TData
  >;
};

export type GetApiProductProductIdQuoteHistQueryResult = NonNullable<
  Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>
>;
export type GetApiProductProductIdQuoteHistQueryError = unknown;

/**
 * @summary Get Price History
 */

export function useGetApiProductProductIdQuoteHist<
  TData = Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>,
  TError = unknown,
>(
  productId: MaybeRef<number>,
  params?: MaybeRef<GetApiProductProductIdQuoteHistParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getApiProductProductIdQuoteHist>>,
        TError,
        TData
      >
    >;
    fetch?: RequestInit;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetApiProductProductIdQuoteHistQueryOptions(
    productId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}
